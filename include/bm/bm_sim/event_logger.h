/* Copyright 2013-present Barefoot Networks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Antonin Bas (antonin@barefootnetworks.com)
 *
 */

//! @file event_logger.h
//! @brief Structured event logger for BMv2. Enables machine-readable packet trace collection
//!        (e.g., via JSON or Protobuf), not just console logs.

#ifndef BM_BM_SIM_EVENT_LOGGER_H_
#define BM_BM_SIM_EVENT_LOGGER_H_

#include <bm/config.h>

#include <memory>
#include <string>
#include <utility>

#include "device_id.h"
#include "phv_forward.h"
#include "transport.h"

namespace bm {

class Packet;

// Forward declarations for P4 object classes, to avoid circular dependencies
class Parser;
class Deparser;
class MatchTableAbstract;
class MatchEntry;
class ActionFn;
struct ActionData;
class Conditional;
class Checksum;
class Pipeline;

using entry_handle_t = uint32_t;

//! @class EventLogger
//! @brief Publishes structured event messages representing significant packet processing events.
//!
//! This logger is intended as the canonical source for structured, machine-parsable event logs
//! (e.g., for automated packet tracing or test analysis). It is designed to support multiple
//! output formats (text, JSON, Protobuf, etc.) and transports (e.g., nanomsg PUB/SUB).
//!
//! Most messages are generated by bmv2 code, but packet_in/packet_out events may be logged by the target.
//! The event logger should be extended, not bypassed, for all future packet trace capabilities.
class EventLogger {
 public:
  explicit EventLogger(std::unique_ptr<TransportIface> transport,
                       device_id_t device_id = 0)
      : transport_instance(std::move(transport)), device_id(device_id) { }

  // Ingress/egress ports are part of the Packet
  //! Signal that a packet was received by the switch
  void packet_in(const Packet &packet);
  //! Signal that a packet was transmitted by the switch
  void packet_out(const Packet &packet);

  void parser_start(const Packet &packet, const Parser &parser);
  void parser_done(const Packet &packet, const Parser &parser);
  void parser_extract(const Packet &packet, header_id_t header);

  void deparser_start(const Packet &packet, const Deparser &deparser);
  void deparser_done(const Packet &packet, const Deparser &deparser);
  void deparser_emit(const Packet &packet, header_id_t header);

  void checksum_update(const Packet &packet, const Checksum &checksum);

  void pipeline_start(const Packet &packet, const Pipeline &pipeline);
  void pipeline_done(const Packet &packet, const Pipeline &pipeline);

  void condition_eval(const Packet &packet,
                      const Conditional &cond, bool result);
  void table_hit(const Packet &packet,
                 const MatchTableAbstract &table, entry_handle_t handle);
  void table_miss(const Packet &packet, const MatchTableAbstract &table);

  void action_execute(const Packet &packet,
                      const ActionFn &action_fn, const ActionData &action_data);

  void config_change();

  //! Future extension: support multiple output formats (text, JSON, Protobuf).
  //! Implementations should override this to produce machine-readable traces.
  virtual void set_output_format(const std::string &format) {
    // Example: "protobuf", "json", "text"
    // Default: no-op. Extend in subclass or implementation.
    (void)format;
  }

  static EventLogger *get() {
    static EventLogger event_logger(TransportIface::make_dummy());
    return &event_logger;
  }

  static void init(std::unique_ptr<TransportIface> transport,
                   device_id_t device_id = 0) {
    get()->transport_instance = std::move(transport);
    get()->device_id = device_id;
  }

 protected:
  std::unique_ptr<TransportIface> transport_instance{nullptr};
  device_id_t device_id{};
};

}  // namespace bm

//! Log an event with the event logger.
//! For example:
//! @code
//! BMELOG(packet_in, packet);
//! // packet processing
//! BMELOG(packet_out, packet);
//! @endcode
#ifdef BM_ELOG_ON
#define BMELOG(fn, ...) bm::EventLogger::get()->fn(__VA_ARGS__)
#else
#define BMELOG(fn, ...)
#endif

#endif  // BM_BM_SIM_EVENT_LOGGER_H_
