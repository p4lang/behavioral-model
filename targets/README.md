# Behavioral model targets

The targets below are not listed in alphabetical order, but _roughly_
by the order of recommendation of their use, from most recommended to
least.


## `simple_switch`

This target is a software switch, running on a general purpose CPU
such as Intel/AMD/etc., that can execute most P4_14 and P4_16
programs, with only a few restrictions on the features used by those
P4 programs.

It implements the P4 features listed below.  They correspond to the
P4_14 language specification, and also with P4_16 plus the `v1model`
architecture, which is intended to match the architecture defined in
the P4_14 language specification:

+ counters
+ meters
+ registers
+ action profiles
+ action selectors
+ several hash and checksum functions
+ pseudo-random number generation
+ digest messages generated by the data plane, sent to the control plane
+ A switch architecture with ingress parser, ingress control, packet
  buffer with packet replication engine, egress control, and egress
  deparser.
  + multicast replication
  + cloning/mirroring of packets
  + resubmit packets, from end of ingress back to start of ingress
  + recirculate packets, from end of egress back to start of ingress

This target can accept TCP connections from a controller, where the
format of control messages on this connection is defined by a Thrift
API.  The P4 program loaded into this target can change while it is
running, and the target executable need not be recompiled in order to
use the new control plane messages for that new P4 program, i.e. the
control plane API is program independent (PI).

References:

+ [Specification documents](https://p4.org/specs/) for P4_14 and P4_16
  languages.
+ The include file [`v1model.p4`](https://github.com/p4lang/p4c/blob/master/p4include/v1model.p4)
  defining the `v1model` architecture for P4_16 programs, and the
  [`simple_switch` documentation](../docs/simple_switch.md) giving
  more details of this architecture and its implementation in
  `simple_switch`.
+ [Instructions](../README.md#using-the-cli-to-populate-tables) for
  running a Python program as a controller, and connecting to
  `simple_switch`.


## `simple_switch_grpc`

This target is based on the `simple_switch` target described above.
The primary difference is that `simple_switch_grpc` can also accept
TCP connections from a controller, where the format of control
messages on this connection are defined by the [P4Runtime API
specification](https://github.com/p4lang/p4runtime).

`simple_switch_grpc` can still also accept connections from
controllers using the Thrift API, but this is primarily intended for
debug purposes.  It is recommended that you do _not_ attempt to have
multiple controllers controlling the same target device, one
controller using the Thrift API, and another using the P4Runtime API.
This is not intended to be a useful mode of operation.


## `psa_switch`

This target is similar to the `simple_switch` described above, except
that `psa_switch` does not use the `v1model` P4_16 architecture, but
instead the [Portable Switch Architecture](https://p4.org/specs/)
(PSA).

As of November 2018 the implementation is not yet complete.  Anyone
interested in helping to complete the implementation (which also
requires additional work in the [P4 compiler
`p4c`](https://github.com/p4lang/p4c)) should create an issue in this
Github repository, or the one for `p4c`.


## `simple_router` and `l2_switch`

These targets were introduced to illustrate how the bmv2 library can
be leveraged to implement different architectures.  They support much
smaller sets of standard metadata, and `simple_router` does not have
an egress control flow.  There is no good reason to use these targets
over `simple_switch` as of November 2018, and they cannot be used with
P4_16 programs.
